# å•†åŸå»ºæ¨¡å™¨åŸºç¡€å­¦ä¹ æŒ‡å—

> è‹æ ¼æ‹‰åº•å¼æ•™å­¦ï¼šé€šè¿‡æé—®å¼•å¯¼ä½ ç†è§£ 3D å•†åŸå»ºæ¨¡å™¨çš„è®¾è®¡

## ç¬¬ä¸€éƒ¨åˆ†ï¼šç†è§£é—®é¢˜

### é—®é¢˜ 1ï¼šå»ºæ¨¡å™¨éœ€è¦åšä»€ä¹ˆï¼Ÿ

åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ï¼Œç”¨æˆ·å¯ä»¥åœ¨ 3D åœºæ™¯ä¸­è®¾è®¡å•†åŸå¸ƒå±€ã€‚

**å»ºæ¨¡å™¨éœ€è¦æ”¯æŒå“ªäº›æ“ä½œï¼Ÿ**

è¯·å…ˆæ€è€ƒ 30 ç§’...

---

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹å¼•å¯¼</summary>

æ ¸å¿ƒåŠŸèƒ½ï¼š

1. **åˆ›å»ºå¯¹è±¡**
   - æ¥¼å±‚ã€åŒºåŸŸã€åº—é“º
   - ç”µæ¢¯ã€æ‰¶æ¢¯ã€æ¥¼æ¢¯
   - å®¶å…·ã€è®¾æ–½

2. **ç¼–è¾‘å¯¹è±¡**
   - ç§»åŠ¨ã€æ—‹è½¬ã€ç¼©æ”¾
   - ä¿®æ”¹å±æ€§ï¼ˆé¢œè‰²ã€åç§°ç­‰ï¼‰

3. **é€‰æ‹©å¯¹è±¡**
   - ç‚¹å‡»é€‰ä¸­
   - æ˜¾ç¤ºé€‰ä¸­çŠ¶æ€
   - æ˜¾ç¤ºå±æ€§é¢æ¿

4. **ä¿å­˜/åŠ è½½**
   - å¯¼å‡ºä¸º JSON
   - ä» JSON æ¢å¤

5. **è§†è§’æ§åˆ¶**
   - æ—‹è½¬ã€ç¼©æ”¾ã€å¹³ç§»
   - åˆ‡æ¢æ¥¼å±‚è§†å›¾

</details>

---

### é—®é¢˜ 2ï¼šä¸ºä»€ä¹ˆè¦åˆ†å±‚è®¾è®¡ï¼Ÿ

çœ‹é¡¹ç›®çš„ç›®å½•ç»“æ„ï¼š

```
builder/
â”œâ”€â”€ objects/       # 3D æ¨¡å‹ï¼ˆç”µæ¢¯ã€æ‰¶æ¢¯ã€å®¶å…·ï¼‰
â”œâ”€â”€ geometry/      # å‡ ä½•è®¡ç®—ï¼ˆå¤šè¾¹å½¢ã€ç¢°æ’æ£€æµ‹ï¼‰
â”œâ”€â”€ materials/     # æè´¨ç®¡ç†
â”œâ”€â”€ resources/     # èµ„æºç¼“å­˜
â”œâ”€â”€ templates/     # å•†åŸæ¨¡æ¿
â”œâ”€â”€ tools/         # ç¼–è¾‘å·¥å…·
â””â”€â”€ types/         # ç±»å‹å®šä¹‰
```

**ä¸ºä»€ä¹ˆä¸æŠŠæ‰€æœ‰ä»£ç æ”¾åœ¨ä¸€ä¸ªæ–‡ä»¶é‡Œï¼Ÿ**

---

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹å¼•å¯¼</summary>

åˆ†å±‚çš„å¥½å¤„ï¼š

1. **å•ä¸€èŒè´£**
   - æ¯ä¸ªæ¨¡å—åªåšä¸€ä»¶äº‹
   - ä¿®æ”¹ä¸€ä¸ªåŠŸèƒ½ä¸å½±å“å…¶ä»–

2. **å¯å¤ç”¨**
   - æè´¨ç®¡ç†å¯ä»¥è¢«å¤šä¸ªæ¨¡å‹ä½¿ç”¨
   - å‡ ä½•è®¡ç®—å¯ä»¥è¢«å¤šä¸ªå·¥å…·ä½¿ç”¨

3. **å¯æµ‹è¯•**
   - æ¯ä¸ªæ¨¡å—å¯ä»¥ç‹¬ç«‹æµ‹è¯•
   - ä¸éœ€è¦å¯åŠ¨æ•´ä¸ªåº”ç”¨

4. **å¯ç»´æŠ¤**
   - æ–°äººå®¹æ˜“ç†è§£
   - å®¹æ˜“å®šä½é—®é¢˜

**ç±»æ¯”**ï¼š
- ä¸€ä¸ªæ–‡ä»¶ = ä¸€ä¸ªäººåšæ‰€æœ‰äº‹
- åˆ†å±‚ = å›¢é˜Ÿåˆ†å·¥åä½œ

</details>

---

## ç¬¬äºŒéƒ¨åˆ†ï¼š3D å¯¹è±¡ç»„ç»‡

### é—®é¢˜ 3ï¼š`THREE.Group` æ˜¯ä»€ä¹ˆï¼Ÿ

çœ‹ç”µæ¢¯æ¨¡å‹çš„ä»£ç ï¼š

```typescript
export function createElevatorModel(
  group: THREE.Group,
  size: number,
  color: number,
  isSelected: boolean
): void {
  // åˆ›å»ºå„ä¸ªéƒ¨ä»¶
  const backWall = new THREE.Mesh(geometry, material)
  group.add(backWall)
  
  const leftWall = new THREE.Mesh(geometry, material)
  group.add(leftWall)
  
  // ...æ›´å¤šéƒ¨ä»¶
}
```

**ä¸ºä»€ä¹ˆè¦ç”¨ `Group` è€Œä¸æ˜¯ç›´æ¥æ·»åŠ åˆ° `Scene`ï¼Ÿ**

---

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹å¼•å¯¼</summary>

`Group` æ˜¯ä¸€ä¸ªå®¹å™¨ï¼Œå¯ä»¥åŒ…å«å¤šä¸ª 3D å¯¹è±¡ã€‚

å¥½å¤„ï¼š

1. **æ•´ä½“æ“ä½œ**
   ```typescript
   // ç§»åŠ¨æ•´ä¸ªç”µæ¢¯ï¼ˆæ‰€æœ‰éƒ¨ä»¶ä¸€èµ·ç§»åŠ¨ï¼‰
   elevatorGroup.position.set(10, 0, 5)
   
   // æ—‹è½¬æ•´ä¸ªç”µæ¢¯
   elevatorGroup.rotation.y = Math.PI / 2
   ```

2. **å±‚çº§ç»“æ„**
   ```
   Scene
   â””â”€â”€ Floor1Group
       â”œâ”€â”€ ElevatorGroup
       â”‚   â”œâ”€â”€ BackWall
       â”‚   â”œâ”€â”€ LeftWall
       â”‚   â””â”€â”€ Door
       â””â”€â”€ ShopGroup
           â”œâ”€â”€ Wall
           â””â”€â”€ Counter
   ```

3. **æ–¹ä¾¿åˆ é™¤**
   ```typescript
   // åˆ é™¤æ•´ä¸ªç”µæ¢¯
   scene.remove(elevatorGroup)
   ```

4. **å±€éƒ¨åæ ‡**
   - éƒ¨ä»¶çš„ä½ç½®ç›¸å¯¹äº Group
   - ç§»åŠ¨ Group æ—¶ï¼Œéƒ¨ä»¶è·Ÿç€ç§»åŠ¨

</details>

---

### é—®é¢˜ 4ï¼šä¸ºä»€ä¹ˆæ¨¡å‹å‡½æ•°æ¥æ”¶ `group` å‚æ•°ï¼Ÿ

```typescript
export function createElevatorModel(
  group: THREE.Group,  // å¤–éƒ¨ä¼ å…¥
  size: number,
  color: number,
  isSelected: boolean
): void {
  // å¾€ group é‡Œæ·»åŠ éƒ¨ä»¶
}
```

**ä¸ºä»€ä¹ˆä¸åœ¨å‡½æ•°å†…éƒ¨åˆ›å»º Group å¹¶è¿”å›ï¼Ÿ**

---

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹å¼•å¯¼</summary>

ä¸¤ç§è®¾è®¡çš„å¯¹æ¯”ï¼š

**æ–¹å¼ 1ï¼šå†…éƒ¨åˆ›å»ºå¹¶è¿”å›**
```typescript
function createElevator(): THREE.Group {
  const group = new THREE.Group()
  // æ·»åŠ éƒ¨ä»¶
  return group
}

// ä½¿ç”¨
const elevator = createElevator()
scene.add(elevator)
```

**æ–¹å¼ 2ï¼šå¤–éƒ¨ä¼ å…¥**
```typescript
function createElevator(group: THREE.Group): void {
  // å¾€ group é‡Œæ·»åŠ éƒ¨ä»¶
}

// ä½¿ç”¨
const elevator = new THREE.Group()
createElevator(elevator)
scene.add(elevator)
```

æ–¹å¼ 2 çš„å¥½å¤„ï¼š
- è°ƒç”¨è€…æ§åˆ¶ Group çš„åˆ›å»º
- å¯ä»¥åœ¨åˆ›å»ºå‰è®¾ç½® Group çš„å±æ€§
- å¯ä»¥å¤ç”¨å·²æœ‰çš„ Group
- æ›´çµæ´»

**ä¾èµ–æ³¨å…¥**ï¼šæŠŠä¾èµ–ï¼ˆGroupï¼‰ä»å¤–éƒ¨ä¼ å…¥ï¼Œè€Œä¸æ˜¯å†…éƒ¨åˆ›å»ºã€‚

</details>

---

## ç¬¬ä¸‰éƒ¨åˆ†ï¼šé€‰ä¸­çŠ¶æ€

### é—®é¢˜ 5ï¼šå¦‚ä½•è¡¨ç¤º"é€‰ä¸­"çŠ¶æ€ï¼Ÿ

```typescript
export function createElevatorModel(
  group: THREE.Group,
  size: number,
  color: number,
  isSelected: boolean  // æ˜¯å¦é€‰ä¸­
): void {
  // æŒ‡ç¤ºç¯æè´¨æ ¹æ®é€‰ä¸­çŠ¶æ€å˜åŒ–
  const indicatorMaterial = createIndicatorMaterial(color, isSelected)
}
```

**é€‰ä¸­çŠ¶æ€å¦‚ä½•å½±å“æ¸²æŸ“ï¼Ÿ**

---

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹å¼•å¯¼</summary>

é€‰ä¸­çŠ¶æ€çš„è§†è§‰åé¦ˆï¼š

1. **é¢œè‰²å˜åŒ–**
   ```typescript
   function createIndicatorMaterial(color: number, isSelected: boolean) {
     const actualColor = isSelected ? 0x00ff00 : color  // é€‰ä¸­æ—¶å˜ç»¿
     return getMaterialManager().getStandardMaterial({
       color: actualColor,
       emissive: actualColor,
       emissiveIntensity: 0.5,
     })
   }
   ```

2. **å‘å…‰æ•ˆæœ**
   - `emissive`ï¼šè‡ªå‘å…‰é¢œè‰²
   - `emissiveIntensity`ï¼šå‘å…‰å¼ºåº¦
   - é€‰ä¸­æ—¶æ›´äº®

3. **è½®å»“çº¿**ï¼ˆå¦ä¸€ç§æ–¹å¼ï¼‰
   - ç»™é€‰ä¸­å¯¹è±¡æ·»åŠ æè¾¹
   - ä½¿ç”¨åå¤„ç†æ•ˆæœ

**é—®é¢˜**ï¼šå¦‚æœé€‰ä¸­çŠ¶æ€å˜åŒ–ï¼Œéœ€è¦é‡æ–°åˆ›å»ºæ¨¡å‹å—ï¼Ÿ

</details>

---

### é—®é¢˜ 6ï¼šé€‰ä¸­çŠ¶æ€å˜åŒ–æ—¶å¦‚ä½•æ›´æ–°ï¼Ÿ

**å½“ç”¨æˆ·ç‚¹å‡»å¦ä¸€ä¸ªå¯¹è±¡æ—¶ï¼Œä¹‹å‰é€‰ä¸­çš„å¯¹è±¡éœ€è¦å–æ¶ˆé€‰ä¸­ã€‚å¦‚ä½•å®ç°ï¼Ÿ**

---

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹å¼•å¯¼</summary>

ä¸¤ç§æ–¹å¼ï¼š

**æ–¹å¼ 1ï¼šé‡æ–°åˆ›å»ºæ¨¡å‹**
```typescript
function updateSelection(newSelected: THREE.Group) {
  // é‡æ–°åˆ›å»ºæ—§å¯¹è±¡ï¼ˆisSelected = falseï¼‰
  recreateModel(oldSelected, false)
  
  // é‡æ–°åˆ›å»ºæ–°å¯¹è±¡ï¼ˆisSelected = trueï¼‰
  recreateModel(newSelected, true)
}
```
- ç®€å•ä½†æ€§èƒ½å·®
- æ¯æ¬¡é€‰ä¸­éƒ½è¦é‡å»º

**æ–¹å¼ 2ï¼šåªæ›´æ–°æè´¨**
```typescript
function updateSelection(newSelected: THREE.Group) {
  // æ›´æ–°æ—§å¯¹è±¡çš„æè´¨
  updateMaterial(oldSelected, false)
  
  // æ›´æ–°æ–°å¯¹è±¡çš„æè´¨
  updateMaterial(newSelected, true)
}

function updateMaterial(group: THREE.Group, isSelected: boolean) {
  const indicator = group.getObjectByName('indicator')
  if (indicator instanceof THREE.Mesh) {
    indicator.material = createIndicatorMaterial(color, isSelected)
  }
}
```
- æ€§èƒ½å¥½
- éœ€è¦èƒ½æ‰¾åˆ°è¦æ›´æ–°çš„éƒ¨ä»¶

**æœ€ä½³å®è·µ**ï¼šç»™é‡è¦éƒ¨ä»¶å‘½åï¼Œæ–¹ä¾¿åç»­æŸ¥æ‰¾å’Œæ›´æ–°ã€‚

</details>

---

## ç¬¬å››éƒ¨åˆ†ï¼šå‡ ä½•è®¡ç®—

### é—®é¢˜ 7ï¼šç¢°æ’æ£€æµ‹æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ

åœ¨æ¼«æ¸¸æ¨¡å¼ä¸­ï¼Œè§’è‰²ä¸èƒ½ç©¿å¢™ã€‚

```typescript
private isInsideBoundary(x: number, z: number): boolean {
  const point2D: Point2D = { x: x, y: -z }
  
  // æ£€æŸ¥æ˜¯å¦åœ¨å•†åŸè¾¹ç•Œå†…
  if (this.boundary && !isPointInside(point2D, this.boundary)) {
    return false
  }
  
  // æ£€æŸ¥æ˜¯å¦åœ¨ä»»ä½•éšœç¢ç‰©å†…
  for (const obstacle of this.obstacles) {
    if (isPointInside(point2D, obstacle)) {
      return false
    }
  }
  
  return true
}
```

**`isPointInside` æ˜¯å¦‚ä½•åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…çš„ï¼Ÿ**

---

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹å¼•å¯¼</summary>

**å°„çº¿æ³•ï¼ˆRay Castingï¼‰**ï¼š

ä»ç‚¹å‘ä»»æ„æ–¹å‘å‘å°„ä¸€æ¡å°„çº¿ï¼Œæ•°å°„çº¿ä¸å¤šè¾¹å½¢è¾¹çš„äº¤ç‚¹æ•°ï¼š
- å¥‡æ•°ä¸ªäº¤ç‚¹ â†’ ç‚¹åœ¨å¤šè¾¹å½¢å†…
- å¶æ•°ä¸ªäº¤ç‚¹ â†’ ç‚¹åœ¨å¤šè¾¹å½¢å¤–

```
        *  (ç‚¹åœ¨å¤–éƒ¨)
       /
      /
     /____
    |     |
    |  *  |  (ç‚¹åœ¨å†…éƒ¨)
    |_____|
```

ä¸ºä»€ä¹ˆæœ‰æ•ˆï¼Ÿ
- ä»å¤–éƒ¨è¿›å…¥å¤šè¾¹å½¢ï¼Œç©¿è¿‡ 1 æ¡è¾¹
- ä»å†…éƒ¨å‡ºå»ï¼Œå†ç©¿è¿‡ 1 æ¡è¾¹
- å†…éƒ¨çš„ç‚¹ï¼šè¿›å…¥ 1 æ¬¡ï¼Œå‡ºå» 1 æ¬¡ = å¥‡æ•°
- å¤–éƒ¨çš„ç‚¹ï¼šè¿›å…¥ 0 æ¬¡ = å¶æ•°

**æ³¨æ„**ï¼šè¿™æ˜¯ 2D ç¢°æ’æ£€æµ‹ï¼ŒY è½´ï¼ˆé«˜åº¦ï¼‰è¢«å¿½ç•¥ã€‚

</details>

---

### é—®é¢˜ 8ï¼šä¸ºä»€ä¹ˆè¦æ£€æŸ¥å¤šä¸ªç‚¹ï¼Ÿ

```typescript
const checkPoints = [
  { x: newX, z: newZ },                    // ä¸­å¿ƒ
  { x: newX + this.collisionRadius, z: newZ },  // å³
  { x: newX - this.collisionRadius, z: newZ },  // å·¦
  { x: newX, z: newZ + this.collisionRadius },  // å‰
  { x: newX, z: newZ - this.collisionRadius },  // å
]

let canMove = true
for (const pt of checkPoints) {
  if (!this.isInsideBoundary(pt.x, pt.z)) {
    canMove = false
    break
  }
}
```

**ä¸ºä»€ä¹ˆä¸åªæ£€æŸ¥è§’è‰²ä¸­å¿ƒç‚¹ï¼Ÿ**

---

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹å¼•å¯¼</summary>

åªæ£€æŸ¥ä¸­å¿ƒç‚¹çš„é—®é¢˜ï¼š

```
     å¢™
      |
   [è§’è‰²]  â† ä¸­å¿ƒç‚¹åœ¨è¾¹ç•Œå†…
      |      ä½†èº«ä½“å·²ç»ç©¿å¢™äº†
      |
```

æ£€æŸ¥å¤šä¸ªç‚¹ï¼š

```
     å¢™
      |
   [*è§’è‰²*]  â† æ£€æŸ¥ 5 ä¸ªç‚¹
      |        ä»»ä½•ä¸€ä¸ªç‚¹å‡ºç•Œå°±ä¸èƒ½ç§»åŠ¨
      |
```

**`collisionRadius`**ï¼šè§’è‰²çš„"ç¢°æ’åŠå¾„"ï¼Œæ¨¡æ‹Ÿè§’è‰²çš„ä½“ç§¯ã€‚

**æ›´ç²¾ç¡®çš„æ–¹å¼**ï¼š
- ä½¿ç”¨åœ†å½¢ç¢°æ’æ£€æµ‹
- ä½¿ç”¨ç‰©ç†å¼•æ“ï¼ˆå¦‚ Cannon.jsï¼‰
- ä½†å¯¹äºç®€å•åœºæ™¯ï¼Œ5 ç‚¹æ£€æµ‹è¶³å¤Ÿäº†

</details>

---

## ç¬¬äº”éƒ¨åˆ†ï¼šæ¨¡æ¿ç³»ç»Ÿ

### é—®é¢˜ 9ï¼šå•†åŸæ¨¡æ¿æ˜¯ä»€ä¹ˆï¼Ÿ

**ç”¨æˆ·å¯ä»¥ä»é¢„è®¾æ¨¡æ¿å¼€å§‹åˆ›å»ºå•†åŸï¼Œè€Œä¸æ˜¯ä»é›¶å¼€å§‹ã€‚æ¨¡æ¿åº”è¯¥åŒ…å«ä»€ä¹ˆï¼Ÿ**

---

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹å¼•å¯¼</summary>

æ¨¡æ¿å†…å®¹ï¼š

1. **åŸºç¡€ç»“æ„**
   - å•†åŸè½®å»“ï¼ˆå¤šè¾¹å½¢ï¼‰
   - æ¥¼å±‚æ•°é‡å’Œé«˜åº¦
   - å…¥å£ä½ç½®

2. **é¢„è®¾åŒºåŸŸ**
   - ç”µæ¢¯äº•ä½ç½®
   - æ‰¶æ¢¯ä½ç½®
   - å…¬å…±åŒºåŸŸ

3. **é»˜è®¤é…ç½®**
   - æè´¨é¢œè‰²
   - ç¯å…‰è®¾ç½®

æ¨¡æ¿æ ¼å¼ï¼ˆJSONï¼‰ï¼š
```json
{
  "name": "æ ‡å‡†å•†åŸ",
  "outline": [[0,0], [100,0], [100,80], [0,80]],
  "floors": [
    { "level": 1, "height": 5 },
    { "level": 2, "height": 5 }
  ],
  "elevators": [
    { "position": [10, 10], "size": 3 }
  ]
}
```

**å¥½å¤„**ï¼š
- å¿«é€Ÿå¼€å§‹
- ä¿è¯åˆç†çš„å¸ƒå±€
- å¯ä»¥åˆ›å»ºå¤šç§é£æ ¼çš„æ¨¡æ¿

</details>

---

### é—®é¢˜ 10ï¼šå¦‚ä½•ä»æ¨¡æ¿åˆ›å»ºå•†åŸï¼Ÿ

**æ¨¡æ¿æ˜¯ JSON æ•°æ®ï¼Œå¦‚ä½•å˜æˆ 3D åœºæ™¯ï¼Ÿ**

---

<details>
<summary>ğŸ’¡ ç‚¹å‡»æŸ¥çœ‹å¼•å¯¼</summary>

è½¬æ¢æµç¨‹ï¼š

```
JSON æ¨¡æ¿
    â†“
è§£ææ•°æ®
    â†“
åˆ›å»º 3D å¯¹è±¡
    â†“
æ·»åŠ åˆ°åœºæ™¯
```

ä»£ç ç¤ºä¾‹ï¼š
```typescript
function loadTemplate(template: MallTemplate): void {
  // 1. åˆ›å»ºæ¥¼å±‚
  template.floors.forEach(floor => {
    const floorGroup = createFloor(floor.level, floor.height)
    scene.add(floorGroup)
  })
  
  // 2. åˆ›å»ºç”µæ¢¯
  template.elevators.forEach(elevator => {
    const elevatorGroup = new THREE.Group()
    createElevatorModel(elevatorGroup, elevator.size, 0x888888, false)
    elevatorGroup.position.set(elevator.position[0], 0, elevator.position[1])
    scene.add(elevatorGroup)
  })
  
  // 3. åˆ›å»ºè¾¹ç•Œå¢™
  createBoundaryWalls(template.outline)
}
```

**å…³é”®**ï¼šæ¨¡æ¿å®šä¹‰"æ˜¯ä»€ä¹ˆ"ï¼Œä»£ç è´Ÿè´£"æ€ä¹ˆåš"ã€‚

</details>

---

## åŠ¨æ‰‹ç»ƒä¹ 

### ç»ƒä¹  1ï¼šæ·»åŠ æ–°çš„è®¾æ–½ç±»å‹
- åˆ›å»ºä¸€ä¸ª"ä¼‘æ¯åŒº"æ¨¡å‹
- åŒ…å«é•¿æ¤…å’Œåƒåœ¾æ¡¶
- æ”¯æŒé€‰ä¸­çŠ¶æ€

<details>
<summary>ğŸ“ å‚è€ƒç­”æ¡ˆ</summary>

```typescript
// builder/objects/rest-area-model.ts

import * as THREE from 'three'
import { getMaterialManager, getBoxGeometry } from '../resources/resource-manager'

interface RestAreaOptions {
  width: number
  depth: number
  benchCount: number
  color: number
  isSelected: boolean
}

export function createRestAreaModel(
  group: THREE.Group,
  options: RestAreaOptions
): void {
  const { width, depth, benchCount, color, isSelected } = options
  
  // æ¸…ç©ºç°æœ‰å†…å®¹
  while (group.children.length > 0) {
    group.remove(group.children[0])
  }
  
  // åœ°é¢æ ‡è®°
  const floorMaterial = getMaterialManager().getStandardMaterial({
    color: isSelected ? 0x4a9eff : 0xcccccc,
    metalness: 0.1,
    roughness: 0.9,
  })
  const floor = new THREE.Mesh(
    getBoxGeometry(width, 0.02, depth),
    floorMaterial
  )
  floor.position.y = 0.01
  floor.name = 'floor'
  group.add(floor)
  
  // åˆ›å»ºé•¿æ¤…
  const benchSpacing = width / (benchCount + 1)
  for (let i = 0; i < benchCount; i++) {
    const bench = createBench(color, isSelected)
    bench.position.set(
      -width / 2 + benchSpacing * (i + 1),
      0,
      0
    )
    bench.name = `bench_${i}`
    group.add(bench)
  }
  
  // åˆ›å»ºåƒåœ¾æ¡¶ï¼ˆä¸¤ç«¯å„ä¸€ä¸ªï¼‰
  const trashBin1 = createTrashBin(isSelected)
  trashBin1.position.set(-width / 2 + 0.5, 0, depth / 2 - 0.5)
  trashBin1.name = 'trashBin_1'
  group.add(trashBin1)
  
  const trashBin2 = createTrashBin(isSelected)
  trashBin2.position.set(width / 2 - 0.5, 0, depth / 2 - 0.5)
  trashBin2.name = 'trashBin_2'
  group.add(trashBin2)
  
  // è®¾ç½®ç”¨æˆ·æ•°æ®
  group.userData = {
    type: 'restArea',
    width,
    depth,
    benchCount,
    color,
    isSelected,
  }
}

function createBench(color: number, isSelected: boolean): THREE.Group {
  const bench = new THREE.Group()
  
  const woodMaterial = getMaterialManager().getStandardMaterial({
    color: isSelected ? 0x8b6914 : 0x8b4513,
    metalness: 0.0,
    roughness: 0.8,
  })
  
  const metalMaterial = getMaterialManager().getStandardMaterial({
    color: 0x444444,
    metalness: 0.8,
    roughness: 0.3,
  })
  
  // åº§æ¿
  const seat = new THREE.Mesh(
    getBoxGeometry(1.5, 0.05, 0.4),
    woodMaterial
  )
  seat.position.y = 0.45
  seat.castShadow = true
  bench.add(seat)
  
  // é èƒŒ
  const backrest = new THREE.Mesh(
    getBoxGeometry(1.5, 0.4, 0.05),
    woodMaterial
  )
  backrest.position.set(0, 0.7, -0.175)
  backrest.castShadow = true
  bench.add(backrest)
  
  // è…¿ï¼ˆ4æ¡ï¼‰
  const legPositions = [
    [-0.6, 0.225, 0.15],
    [0.6, 0.225, 0.15],
    [-0.6, 0.225, -0.15],
    [0.6, 0.225, -0.15],
  ]
  
  legPositions.forEach(([x, y, z], i) => {
    const leg = new THREE.Mesh(
      getBoxGeometry(0.05, 0.45, 0.05),
      metalMaterial
    )
    leg.position.set(x, y, z)
    leg.castShadow = true
    bench.add(leg)
  })
  
  return bench
}

function createTrashBin(isSelected: boolean): THREE.Group {
  const bin = new THREE.Group()
  
  const binMaterial = getMaterialManager().getStandardMaterial({
    color: isSelected ? 0x2e7d32 : 0x1b5e20,
    metalness: 0.3,
    roughness: 0.6,
  })
  
  // æ¡¶èº«ï¼ˆä½¿ç”¨åœ†æŸ±ä½“ï¼‰
  const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.18, 0.6, 16)
  const body = new THREE.Mesh(bodyGeometry, binMaterial)
  body.position.y = 0.3
  body.castShadow = true
  bin.add(body)
  
  // æ¡¶ç›–
  const lidGeometry = new THREE.CylinderGeometry(0.22, 0.22, 0.05, 16)
  const lid = new THREE.Mesh(lidGeometry, binMaterial)
  lid.position.y = 0.625
  lid.castShadow = true
  bin.add(lid)
  
  return bin
}

// æ›´æ–°é€‰ä¸­çŠ¶æ€
export function updateRestAreaSelection(
  group: THREE.Group,
  isSelected: boolean
): void {
  const userData = group.userData
  if (userData.type === 'restArea') {
    createRestAreaModel(group, {
      ...userData,
      isSelected,
    })
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```typescript
const restArea = new THREE.Group()
createRestAreaModel(restArea, {
  width: 6,
  depth: 3,
  benchCount: 2,
  color: 0x8b4513,
  isSelected: false,
})
scene.add(restArea)

// é€‰ä¸­æ—¶æ›´æ–°
updateRestAreaSelection(restArea, true)
```

**å…³é”®ç‚¹**ï¼š
- ä½¿ç”¨ Group ç»„ç»‡å¤šä¸ªéƒ¨ä»¶
- æ¯ä¸ªéƒ¨ä»¶å‘½åæ–¹ä¾¿åç»­æŸ¥æ‰¾
- é€‰ä¸­çŠ¶æ€å½±å“æè´¨é¢œè‰²
- æä¾›æ›´æ–°å‡½æ•°é¿å…é‡å»ºæ•´ä¸ªæ¨¡å‹

</details>

---

### ç»ƒä¹  2ï¼šå®ç°æ’¤é”€/é‡åš
- è®°å½•æ¯æ¬¡æ“ä½œ
- æ”¯æŒ Ctrl+Z æ’¤é”€
- æ”¯æŒ Ctrl+Y é‡åš

<details>
<summary>ğŸ“ å‚è€ƒç­”æ¡ˆ</summary>

```typescript
// builder/history/command-history.ts

interface Command {
  execute(): void
  undo(): void
  description: string
}

class CommandHistory {
  private undoStack: Command[] = []
  private redoStack: Command[] = []
  private maxHistory: number = 50
  
  /**
   * æ‰§è¡Œå‘½ä»¤å¹¶è®°å½•
   */
  execute(command: Command): void {
    command.execute()
    this.undoStack.push(command)
    
    // æ‰§è¡Œæ–°å‘½ä»¤åæ¸…ç©ºé‡åšæ ˆ
    this.redoStack = []
    
    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (this.undoStack.length > this.maxHistory) {
      this.undoStack.shift()
    }
    
    console.log(`[History] æ‰§è¡Œ: ${command.description}`)
  }
  
  /**
   * æ’¤é”€
   */
  undo(): boolean {
    const command = this.undoStack.pop()
    if (!command) {
      console.log('[History] æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ')
      return false
    }
    
    command.undo()
    this.redoStack.push(command)
    console.log(`[History] æ’¤é”€: ${command.description}`)
    return true
  }
  
  /**
   * é‡åš
   */
  redo(): boolean {
    const command = this.redoStack.pop()
    if (!command) {
      console.log('[History] æ²¡æœ‰å¯é‡åšçš„æ“ä½œ')
      return false
    }
    
    command.execute()
    this.undoStack.push(command)
    console.log(`[History] é‡åš: ${command.description}`)
    return true
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥æ’¤é”€/é‡åš
   */
  canUndo(): boolean {
    return this.undoStack.length > 0
  }
  
  canRedo(): boolean {
    return this.redoStack.length > 0
  }
  
  /**
   * æ¸…ç©ºå†å²
   */
  clear(): void {
    this.undoStack = []
    this.redoStack = []
  }
}

// å•ä¾‹
export const commandHistory = new CommandHistory()

// ============================================================================
// å…·ä½“å‘½ä»¤å®ç°
// ============================================================================

/**
 * æ·»åŠ å¯¹è±¡å‘½ä»¤
 */
export class AddObjectCommand implements Command {
  constructor(
    private scene: THREE.Scene,
    private object: THREE.Object3D,
    public description: string = 'æ·»åŠ å¯¹è±¡'
  ) {}
  
  execute(): void {
    this.scene.add(this.object)
  }
  
  undo(): void {
    this.scene.remove(this.object)
  }
}

/**
 * åˆ é™¤å¯¹è±¡å‘½ä»¤
 */
export class RemoveObjectCommand implements Command {
  private parent: THREE.Object3D | null = null
  
  constructor(
    private object: THREE.Object3D,
    public description: string = 'åˆ é™¤å¯¹è±¡'
  ) {
    this.parent = object.parent
  }
  
  execute(): void {
    this.parent?.remove(this.object)
  }
  
  undo(): void {
    this.parent?.add(this.object)
  }
}

/**
 * ç§»åŠ¨å¯¹è±¡å‘½ä»¤
 */
export class MoveObjectCommand implements Command {
  private oldPosition: THREE.Vector3
  
  constructor(
    private object: THREE.Object3D,
    private newPosition: THREE.Vector3,
    public description: string = 'ç§»åŠ¨å¯¹è±¡'
  ) {
    this.oldPosition = object.position.clone()
  }
  
  execute(): void {
    this.object.position.copy(this.newPosition)
  }
  
  undo(): void {
    this.object.position.copy(this.oldPosition)
  }
}

/**
 * æ—‹è½¬å¯¹è±¡å‘½ä»¤
 */
export class RotateObjectCommand implements Command {
  private oldRotation: THREE.Euler
  
  constructor(
    private object: THREE.Object3D,
    private newRotation: THREE.Euler,
    public description: string = 'æ—‹è½¬å¯¹è±¡'
  ) {
    this.oldRotation = object.rotation.clone()
  }
  
  execute(): void {
    this.object.rotation.copy(this.newRotation)
  }
  
  undo(): void {
    this.object.rotation.copy(this.oldRotation)
  }
}

// ============================================================================
// é”®ç›˜å¿«æ·é”®
// ============================================================================

export function setupHistoryShortcuts(): () => void {
  const handleKeyDown = (event: KeyboardEvent) => {
    // Ctrl+Z æ’¤é”€
    if (event.ctrlKey && event.key === 'z' && !event.shiftKey) {
      event.preventDefault()
      commandHistory.undo()
    }
    
    // Ctrl+Y æˆ– Ctrl+Shift+Z é‡åš
    if (
      (event.ctrlKey && event.key === 'y') ||
      (event.ctrlKey && event.shiftKey && event.key === 'z')
    ) {
      event.preventDefault()
      commandHistory.redo()
    }
  }
  
  window.addEventListener('keydown', handleKeyDown)
  
  // è¿”å›æ¸…ç†å‡½æ•°
  return () => {
    window.removeEventListener('keydown', handleKeyDown)
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```typescript
import { 
  commandHistory, 
  AddObjectCommand, 
  MoveObjectCommand,
  setupHistoryShortcuts 
} from './history/command-history'

// è®¾ç½®å¿«æ·é”®
const cleanup = setupHistoryShortcuts()

// æ·»åŠ å¯¹è±¡ï¼ˆå¯æ’¤é”€ï¼‰
const elevator = new THREE.Group()
createElevatorModel(elevator, 3, 0x888888, false)
commandHistory.execute(new AddObjectCommand(scene, elevator, 'æ·»åŠ ç”µæ¢¯'))

// ç§»åŠ¨å¯¹è±¡ï¼ˆå¯æ’¤é”€ï¼‰
const newPosition = new THREE.Vector3(10, 0, 5)
commandHistory.execute(new MoveObjectCommand(elevator, newPosition, 'ç§»åŠ¨ç”µæ¢¯'))

// æ’¤é”€
commandHistory.undo() // æ’¤é”€ç§»åŠ¨
commandHistory.undo() // æ’¤é”€æ·»åŠ 

// é‡åš
commandHistory.redo() // é‡åšæ·»åŠ 

// æ¸…ç†
cleanup()
```

**å…³é”®ç‚¹**ï¼š
- å‘½ä»¤æ¨¡å¼ï¼šæ¯ä¸ªæ“ä½œå°è£…ä¸ºå‘½ä»¤å¯¹è±¡
- å‘½ä»¤åŒ…å« `execute` å’Œ `undo` æ–¹æ³•
- ä½¿ç”¨ä¸¤ä¸ªæ ˆç®¡ç†æ’¤é”€å’Œé‡åš
- æ‰§è¡Œæ–°å‘½ä»¤æ—¶æ¸…ç©ºé‡åšæ ˆ

</details>

---

### ç»ƒä¹  3ï¼šæ·»åŠ æµ‹é‡å·¥å…·
- ç‚¹å‡»ä¸¤ç‚¹æµ‹é‡è·ç¦»
- æ˜¾ç¤ºè·ç¦»æ•°å€¼

<details>
<summary>ğŸ“ å‚è€ƒç­”æ¡ˆ</summary>

```typescript
// builder/tools/measure-tool.ts

import * as THREE from 'three'

interface MeasureResult {
  start: THREE.Vector3
  end: THREE.Vector3
  distance: number
  line: THREE.Line
  label: THREE.Sprite
}

export class MeasureTool {
  private scene: THREE.Scene
  private camera: THREE.Camera
  private container: HTMLElement
  private raycaster: THREE.Raycaster = new THREE.Raycaster()
  private mouse: THREE.Vector2 = new THREE.Vector2()
  
  private isActive: boolean = false
  private startPoint: THREE.Vector3 | null = null
  private tempLine: THREE.Line | null = null
  private measurements: MeasureResult[] = []
  
  constructor(scene: THREE.Scene, camera: THREE.Camera, container: HTMLElement) {
    this.scene = scene
    this.camera = camera
    this.container = container
  }
  
  /**
   * æ¿€æ´»æµ‹é‡å·¥å…·
   */
  activate(): void {
    this.isActive = true
    this.container.style.cursor = 'crosshair'
    this.container.addEventListener('click', this.handleClick)
    this.container.addEventListener('mousemove', this.handleMouseMove)
  }
  
  /**
   * åœç”¨æµ‹é‡å·¥å…·
   */
  deactivate(): void {
    this.isActive = false
    this.container.style.cursor = 'default'
    this.container.removeEventListener('click', this.handleClick)
    this.container.removeEventListener('mousemove', this.handleMouseMove)
    this.clearTempLine()
    this.startPoint = null
  }
  
  /**
   * å¤„ç†ç‚¹å‡»
   */
  private handleClick = (event: MouseEvent): void => {
    const point = this.getIntersectionPoint(event)
    if (!point) return
    
    if (!this.startPoint) {
      // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼šè®¾ç½®èµ·ç‚¹
      this.startPoint = point.clone()
      this.createStartMarker(point)
    } else {
      // ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼šå®Œæˆæµ‹é‡
      this.completeMeasurement(point)
      this.startPoint = null
    }
  }
  
  /**
   * å¤„ç†é¼ æ ‡ç§»åŠ¨ï¼ˆæ˜¾ç¤ºä¸´æ—¶çº¿ï¼‰
   */
  private handleMouseMove = (event: MouseEvent): void => {
    if (!this.startPoint) return
    
    const point = this.getIntersectionPoint(event)
    if (!point) return
    
    this.updateTempLine(this.startPoint, point)
  }
  
  /**
   * è·å–å°„çº¿ä¸åœºæ™¯çš„äº¤ç‚¹
   */
  private getIntersectionPoint(event: MouseEvent): THREE.Vector3 | null {
    const rect = this.container.getBoundingClientRect()
    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1
    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1
    
    this.raycaster.setFromCamera(this.mouse, this.camera)
    
    // ä¸åœºæ™¯ä¸­çš„ç‰©ä½“ç›¸äº¤
    const intersects = this.raycaster.intersectObjects(this.scene.children, true)
    
    if (intersects.length > 0) {
      return intersects[0].point
    }
    
    // å¦‚æœæ²¡æœ‰äº¤ç‚¹ï¼Œä¸åœ°é¢ç›¸äº¤
    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0)
    const point = new THREE.Vector3()
    this.raycaster.ray.intersectPlane(plane, point)
    return point
  }
  
  /**
   * åˆ›å»ºèµ·ç‚¹æ ‡è®°
   */
  private createStartMarker(point: THREE.Vector3): void {
    const geometry = new THREE.SphereGeometry(0.1, 16, 16)
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
    const marker = new THREE.Mesh(geometry, material)
    marker.position.copy(point)
    marker.name = 'measureStartMarker'
    this.scene.add(marker)
  }
  
  /**
   * æ›´æ–°ä¸´æ—¶çº¿
   */
  private updateTempLine(start: THREE.Vector3, end: THREE.Vector3): void {
    this.clearTempLine()
    
    const geometry = new THREE.BufferGeometry().setFromPoints([start, end])
    const material = new THREE.LineDashedMaterial({
      color: 0xffff00,
      dashSize: 0.2,
      gapSize: 0.1,
    })
    
    this.tempLine = new THREE.Line(geometry, material)
    this.tempLine.computeLineDistances()
    this.tempLine.name = 'measureTempLine'
    this.scene.add(this.tempLine)
  }
  
  /**
   * æ¸…é™¤ä¸´æ—¶çº¿
   */
  private clearTempLine(): void {
    if (this.tempLine) {
      this.scene.remove(this.tempLine)
      this.tempLine.geometry.dispose()
      this.tempLine = null
    }
    
    // æ¸…é™¤èµ·ç‚¹æ ‡è®°
    const marker = this.scene.getObjectByName('measureStartMarker')
    if (marker) {
      this.scene.remove(marker)
    }
  }
  
  /**
   * å®Œæˆæµ‹é‡
   */
  private completeMeasurement(endPoint: THREE.Vector3): void {
    if (!this.startPoint) return
    
    const distance = this.startPoint.distanceTo(endPoint)
    
    // åˆ›å»ºæµ‹é‡çº¿
    const geometry = new THREE.BufferGeometry().setFromPoints([
      this.startPoint,
      endPoint,
    ])
    const material = new THREE.LineBasicMaterial({ color: 0x00ff00 })
    const line = new THREE.Line(geometry, material)
    line.name = `measureLine_${this.measurements.length}`
    this.scene.add(line)
    
    // åˆ›å»ºè·ç¦»æ ‡ç­¾
    const label = this.createDistanceLabel(
      this.startPoint.clone().add(endPoint).multiplyScalar(0.5),
      distance
    )
    this.scene.add(label)
    
    // ä¿å­˜æµ‹é‡ç»“æœ
    this.measurements.push({
      start: this.startPoint.clone(),
      end: endPoint.clone(),
      distance,
      line,
      label,
    })
    
    // æ¸…é™¤ä¸´æ—¶å…ƒç´ 
    this.clearTempLine()
    
    console.log(`æµ‹é‡è·ç¦»: ${distance.toFixed(2)} ç±³`)
  }
  
  /**
   * åˆ›å»ºè·ç¦»æ ‡ç­¾
   */
  private createDistanceLabel(position: THREE.Vector3, distance: number): THREE.Sprite {
    const canvas = document.createElement('canvas')
    const context = canvas.getContext('2d')!
    canvas.width = 128
    canvas.height = 64
    
    context.fillStyle = 'rgba(0, 0, 0, 0.7)'
    context.fillRect(0, 0, canvas.width, canvas.height)
    
    context.fillStyle = '#ffffff'
    context.font = 'bold 24px Arial'
    context.textAlign = 'center'
    context.textBaseline = 'middle'
    context.fillText(`${distance.toFixed(2)}m`, canvas.width / 2, canvas.height / 2)
    
    const texture = new THREE.CanvasTexture(canvas)
    const material = new THREE.SpriteMaterial({ map: texture })
    const sprite = new THREE.Sprite(material)
    
    sprite.position.copy(position)
    sprite.position.y += 0.5 // ç¨å¾®æŠ¬é«˜
    sprite.scale.set(2, 1, 1)
    sprite.name = `measureLabel_${this.measurements.length}`
    
    return sprite
  }
  
  /**
   * æ¸…é™¤æ‰€æœ‰æµ‹é‡
   */
  clearAllMeasurements(): void {
    this.measurements.forEach(m => {
      this.scene.remove(m.line)
      this.scene.remove(m.label)
      m.line.geometry.dispose()
      ;(m.label.material as THREE.SpriteMaterial).map?.dispose()
      ;(m.label.material as THREE.SpriteMaterial).dispose()
    })
    this.measurements = []
  }
  
  /**
   * è·å–æ‰€æœ‰æµ‹é‡ç»“æœ
   */
  getMeasurements(): { start: THREE.Vector3; end: THREE.Vector3; distance: number }[] {
    return this.measurements.map(m => ({
      start: m.start.clone(),
      end: m.end.clone(),
      distance: m.distance,
    }))
  }
  
  /**
   * é”€æ¯
   */
  dispose(): void {
    this.deactivate()
    this.clearAllMeasurements()
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```typescript
const measureTool = new MeasureTool(scene, camera, container)

// æ¿€æ´»æµ‹é‡å·¥å…·
measureTool.activate()

// ç”¨æˆ·ç‚¹å‡»ä¸¤ç‚¹åè‡ªåŠ¨æ˜¾ç¤ºè·ç¦»

// è·å–æ‰€æœ‰æµ‹é‡ç»“æœ
const results = measureTool.getMeasurements()
results.forEach(r => {
  console.log(`ä» ${r.start.toArray()} åˆ° ${r.end.toArray()}: ${r.distance.toFixed(2)}m`)
})

// æ¸…é™¤æ‰€æœ‰æµ‹é‡
measureTool.clearAllMeasurements()

// åœç”¨
measureTool.deactivate()

// é”€æ¯
measureTool.dispose()
```

**å…³é”®ç‚¹**ï¼š
- ä½¿ç”¨ Raycaster è·å–ç‚¹å‡»ä½ç½®
- ä¸´æ—¶çº¿ä½¿ç”¨è™šçº¿æ ·å¼åŒºåˆ†
- ä½¿ç”¨ Sprite + Canvas åˆ›å»ºå§‹ç»ˆé¢å‘ç›¸æœºçš„æ ‡ç­¾
- ä¿å­˜æµ‹é‡ç»“æœæ–¹ä¾¿åç»­ä½¿ç”¨

</details>

---

## å…³é”®æ–‡ä»¶

- `apps/frontend/SMART-MALL/src/builder/objects/` - 3D æ¨¡å‹
- `apps/frontend/SMART-MALL/src/builder/geometry/` - å‡ ä½•è®¡ç®—
- `apps/frontend/SMART-MALL/src/builder/templates/` - å•†åŸæ¨¡æ¿
- `apps/frontend/SMART-MALL/src/builder/resources/` - èµ„æºç®¡ç†

---

*"ç¾å¾·å³çŸ¥è¯†ã€‚" â€”â€” è‹æ ¼æ‹‰åº•*
